description: "Install a chart to microk8s"

parameters:
  chart_name:
    description: "Name of the chart to install"
    type: string
    default: "codacy"
  chart_version:
    description: "Chart version to install. If empty then the latest is installed"
    type: string
    default: ""
  helm_repo:
    type: string
    default: "https://charts.codacy.com/stable"
  helm_version:
    description: "Helm version used to install the chart"
    type: string
    default: "v2.15.1"
  microk8s_channel:
    description: "Microk8s version used"
    type: string
    default: "1.15/stable"
  namespace:
    description: "Namespace where to install the chart"
    type: string
    default: "codacy"
  microk8s_values_content:
    description: "Content for microk8s-values.yaml, used to override chart default values"
    type: string
    default: ""
  microk8s_wait_retries:
    description: "Number of retries to wait for microk8s to be ready"
    type: integer
    default: 20
  kubectl_timeout:
    description: "Time to wait for kubectl commands"
    type: integer
    default: 300
  helm_timeout:
    description: "Time to wait for helm commands"
    type: integer
    default: 300

executor: machine
resource_class: large

steps:
  - attach_workspace:
      at: ~/workdir

  - run:
      name: Setup microk8s and helm
      command: |
        function microk8s_wait_ready() {
          # Microk8s status is flaky, and often lies to you.
          # We really have to make sure it is up before running more commands in CI.
          local RETRIES=$1
          while [[ $RETRIES -gt 0 ]] ; do
            echo  "Waiting for microk8s to become ready... [$RETRIES]"
            set +e
            sudo microk8s.status --wait-ready
            local MICROK8S_STATUS=$?

            sudo microk8s.kubectl get pods --all-namespaces
            local K8S_STATUS=$?
            set -e

            if [[ $MICROK8S_STATUS -eq 0 ]] && [[ $K8S_STATUS -eq 0 ]] ; then return 0 ; fi

            RETRIES=$((RETRIES-1))
          done
          return 1
        }

        # install storage addon dependencies
        sudo apt update && sudo apt install nfs-common -y

        # enable traffic forwarding, which might not be done automatically for earlier microk8s versions
        # see https://github.com/ubuntu/microk8s/tree/1.12#my-pods-cant-reach-the-internet-but-my-microk8s-host-machine-can
        sudo iptables -P FORWARD ACCEPT

        # install microk8s and selected addons
        sudo snap install microk8s --classic --channel << parameters.microk8s_channel >>
        export PATH=$PATH:/snap/bin
        sudo microk8s.start && microk8s_wait_ready << parameters.microk8s_wait_retries >>

        # enabling plugins one at a time to prevent a race condition
        # see https://github.com/ubuntu/microk8s/issues/706
        sudo microk8s.enable dns && microk8s_wait_ready << parameters.microk8s_wait_retries >>
        sudo microk8s.enable storage && microk8s_wait_ready << parameters.microk8s_wait_retries >>
        sudo microk8s.enable ingress && microk8s_wait_ready << parameters.microk8s_wait_retries >>

        # restart to make sure the apparmor profile is correctly created
        # see https://github.com/ubuntu/microk8s/issues/493#issuecomment-498167435
        sudo microk8s.stop && sudo microk8s.start && microk8s_wait_ready << parameters.microk8s_wait_retries >>

        # Wait for kube-dns and hostpath-provisioner, or pods will quickly enter a crashloop
        sudo microk8s.kubectl wait -n kube-system --for=condition=Ready pod -l k8s-app=kube-dns --timeout=<< parameters.kubectl_timeout >>s
        sudo microk8s.kubectl wait -n kube-system --for=condition=Ready pod -l k8s-app=hostpath-provisioner --timeout=<< parameters.kubectl_timeout >>s

        # install helm
        HELM_PKG=helm-<< parameters.helm_version >>-linux-amd64.tar.gz
        wget https://get.helm.sh/$HELM_PKG
        tar xvzf $HELM_PKG
        sudo mv linux-amd64/tiller linux-amd64/helm /usr/local/bin
        rm -rvf $HELM_PKG linux-amd64/

        # install tiller and wait for it to be ready
        sudo microk8s.kubectl create serviceaccount --namespace kube-system tiller
        sudo microk8s.kubectl create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tiller
        sudo helm init --service-account tiller
        sudo microk8s.kubectl -n kube-system wait --for=condition=Ready pod -l name=tiller --timeout=<< parameters.kubectl_timeout >>s

  - run:
      name: Create values file
      command: |
        cat \<< END_VALUES > microk8s-values.yaml
        << parameters.microk8s_values_content >>
        END_VALUES

  - deploy:
      name: Install to microk8s from chart repo
      command: |
        sudo helm repo add default << parameters.helm_repo >>

        # if chart_version is an empty string then the latest version of the chart is installed
        sudo helm install --name << parameters.chart_name >> default/<< parameters.chart_name >> --timeout << parameters.helm_timeout >> \
          --namespace << parameters.namespace >> -f microk8s-values.yaml --version "<< parameters.chart_version >>"
